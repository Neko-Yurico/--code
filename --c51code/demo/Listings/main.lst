C51 COMPILER V9.54   MAIN                                                                  07/05/2021 17:47:42 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keil\MDK\C51\BIN\C51.EXE src\main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings
                    -\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /************************************************************************************
   2          
   3          程序名称：1602显示屏测试程序   （晶振频率12MHz） 
   4          功能说明: 通过1602显示屏显示字符            
   5          程序版本：1.0 （2015/06）
   6          
   7          ************************************************************************************/
   8          
   9          
  10          #include <stdio.h>
  11          #include "stc15f2k60s2.h"                 // 单片机STC15F2K60S2头文件,可以不再加入reg51.h
  12          #include <intrins.h>                      // 加入此头文件后,可使用_nop_库函数
  13          #include "delay.h"                        // 延时函数头文件
  14          #include "1602.h"                         // 1602显示屏驱动程序头文件
  15          #include "uart.h"
  16          
  17          sbit Data = P1 ^7;
  18          sbit key1 = P2 ^3;
  19          sbit key2 = P2 ^2;
  20          sbit key3 = P2 ^1;
  21          sbit key4 = P2 ^0;
  22          sbit d1 = P5 ^2;
  23          sbit d2 = P5 ^1;
  24          sbit d3 = P5 ^0;
  25          
  26          int limit = 30;                                   //温度上限
  27          unsigned char rec_dat[14] = "   RH       C ";
  28          unsigned char RH, RL, TH, TL, revise;
  29          unsigned char warnFlag = 0;                       //是否报警
  30          unsigned char kickFlag = 0;                       //是否取消报警
  31          
  32          void io_init(void);
  33          void UartInit(void);
  34          void DHT11_receive();
  35          
  36          void main(void) {
  37   1          unsigned char i = 0;
  38   1          unsigned char flag = 1;
  39   1          char strTemp[20]; 
  40   1          io_init();
  41   1          d3 = 0;
  42   1          lcd_init();                                   //LCD初始化
  43   1          DelayMS(5);
  44   1          lcd_clear();                                  //清屏函数
  45   1          DelayMS(5);
  46   1          lcd_write_string(0, 0, "hello EIE 194");
  47   1          DelayMS(1000);
  48   1          while (1) {
  49   2              DHT11_receive();  
  50   2              if (key1 == 0) {                          //进入模式1
  51   3                  DelayMS(30);
  52   3                  if (key1 == 0) {
  53   4                      d1 = 0;
  54   4                      d2 = 1;
C51 COMPILER V9.54   MAIN                                                                  07/05/2021 17:47:42 PAGE 2   

  55   4                      d3 = 1;
  56   4                      lcd_clear();
  57   4                      DelayMS(5);
  58   4                      lcd_write_string(0, 0, "MOD1         ");
  59   4                      lcd_write_string(0, 1, "The default mode");
  60   4                      while (key1 == 0);
  61   4                      DelayMS(200);
  62   4                      kickFlag = 0;
  63   4                      warnFlag = 0;
  64   4                  }
  65   3              }
  66   2              if (key2 == 0) {                          //进入模式2
  67   3                  DelayMS(30);
  68   3                  if (key2 == 0) {
  69   4                      d1 = 1;
  70   4                      d2 = 0;
  71   4                      d3 = 1;
  72   4                      lcd_clear();
  73   4                      DelayMS(5);
  74   4                      lcd_write_string(0, 0, "MOD2         ");
  75   4                      while (key2 == 0);
  76   4                      DelayMS(200);
  77   4                      DHT11_receive();
  78   4                      lcd_clear();
  79   4                      DelayMS(5);
  80   4                      lcd_write_string(0, 0, "COMMAND Mod");
  81   4                      lcd_write_string(0, 1, "Use K4 To UPDATE");
  82   4                      kickFlag = 0;
  83   4                      warnFlag = 0;
  84   4                  }
  85   3              }
  86   2              if (key3 == 0 && warnFlag == 0) {         //进入模式3――设定温度上限1
  87   3                  DelayMS(30);
  88   3                  if (key3 == 0) {
  89   4                      d1 = 1;
  90   4                      d2 = 1;
  91   4                      d3 = 0;
  92   4                      lcd_clear();
  93   4                      DelayMS(5);
  94   4                      lcd_write_string(0, 0, "MOD3         ");
  95   4                      while (key3 == 0);
  96   4                      DelayMS(200);
  97   4                      d3 = 1;
  98   4                      lcd_clear();
  99   4                      DelayMS(5);
 100   4                      lcd_write_string(0, 0, "SET upper limit");
 101   4                      lcd_write_string(0, 1, "USE K4 to SET");
 102   4                  }
 103   3              }
 104   2              if (d1 == 0) {                            //当蓝灯亮时，显示温度和湿度，并发送给上位机
 105   3                  //DHT11_receive();  
 106   3                  lcd_clear();
 107   3                  DelayMS(5);
 108   3                  lcd_write_string(0, 0, "Auto detecting");
 109   3                  lcd_write_string(0, 1, rec_dat);
 110   3                  UartInit();
 111   3                  SendString(rec_dat);
 112   3                  DelayMS(1000);
 113   3              }
 114   2              if (d2 == 0) {                            //当绿灯亮时，按下k4可显示温度和湿度，并发送给上位机
 115   3                //DHT11_receive();
 116   3                lcd_clear();
C51 COMPILER V9.54   MAIN                                                                  07/05/2021 17:47:42 PAGE 3   

 117   3                DelayMS(5);
 118   3                lcd_write_string(0, 0, "COMMAND Mod");
 119   3                lcd_write_string(0, 1, rec_dat);
 120   3                if (key4 == 0) {
 121   4                      DelayMS(30);
 122   4                      if (key4 == 0) {
 123   5                          lcd_write_string(0, 0, "Has been sent      ");
 124   5                          UartInit();
 125   5                          SendString(rec_dat);
 126   5                          DelayMS(1000);
 127   5                          while (key4 == 0);
 128   5                          //DelayMS(100);
 129   5                      }
 130   4                  }/*else{
 131   3                      DHT11_receive();
 132   3                      lcd_clear();
 133   3                      DelayMS(5);
 134   3                      lcd_write_string(0, 0, "COMMAND Mod");
 135   3                      lcd_write_string(0, 1, "Use K4 To UPDATE");
 136   3                  }*/
 137   3                    
 138   3              }
 139   2              if (d1 == 1 && d2 == 1 && d3 == 1 && warnFlag == 0) {      //设定温度上限2
 140   3                  if (key4 == 0) {
 141   4                      DelayMS(30);
 142   4                      if (key4 == 0) {
 143   5                          while (key4 == 0); 
 144   5                          DelayMS(100);
 145   5                      }
 146   4                      while (key4 != 0) {
 147   5                          //DHT11_receive();
 148   5                          lcd_clear();
 149   5                          DelayMS(5);
 150   5                          lcd_write_string(0, 0, "k1=up k2=down");
 151   5                          sprintf(strTemp, "%d", limit); 
 152   5                          lcd_write_string(0, 1, "    K4 to exit");
 153   5                          lcd_write_string(0, 1, strTemp);
 154   5                          if (key1 == 0) {
 155   6                              DelayMS(30);
 156   6                              if (key1 == 0) {
 157   7                                  limit ++;
 158   7                                  while (key1 == 0);
 159   7                              }
 160   6                          }
 161   5                          if (key2 == 0) {
 162   6                              DelayMS(30);
 163   6                              if (key2 == 0) {
 164   7                                  limit --;
 165   7                                  while (key2 == 0);
 166   7                              }
 167   6                          }
 168   5                      }
 169   4                      d3=0;
 170   4                      DHT11_receive();
 171   4                      lcd_clear();
 172   4                      DelayMS(5);
 173   4                      lcd_write_string(0, 0, "SET Finish");
 174   4                      lcd_write_string(0, 1, "USE K1/K2 to Exit");
 175   4                      kickFlag = 0;
 176   4                      warnFlag = 0;
 177   4                  }
 178   3              }
C51 COMPILER V9.54   MAIN                                                                  07/05/2021 17:47:42 PAGE 4   

 179   2              while(TH >= limit && kickFlag == 0){
 180   3                d1 = 1;
 181   3                d2 = 1;
 182   3                d3 = ~d3;
 183   3                warnFlag = 1;
 184   3                //DHT11_receive();
 185   3                lcd_clear();
 186   3                DelayMS(5);
 187   3                lcd_write_string(0, 0, "TEMP OVERRUN!"); 
 188   3                lcd_write_string(0, 1, "KICK K4 TO CLOSE");
 189   3                DelayMS(200);
 190   3                if(key4 == 0){
 191   4                  d3 = 1;
 192   4                  kickFlag = 1;
 193   4                  warnFlag = 0;
 194   4                  //DHT11_receive();
 195   4                  lcd_clear();
 196   4                  DelayMS(5);
 197   4                  lcd_write_string(0, 0, "ALARM turned off");
 198   4                  DelayMS(1500);
 199   4                  lcd_write_string(0, 0, "hello EIE 194   ");
 200   4                }
 201   3              } 
 202   2           }
 203   1      /*        if(TH >= limit && flag == 1){
 204   1                if (key4 != 0) {
 205   1                  DelayMS(30);
 206   1                  if (key4 != 0) {
 207   1                    warning();
 208   1                    DelayMS(200);
 209   1                  }
 210   1                }
 211   1                if (key4 == 0) {  
 212   1                  DelayMS(30);
 213   1                  if (key4 == 0) {
 214   1                    flag=0;
 215   1                    d3 = 1;
 216   1                    DHT11_receive();
 217   1                    lcd_clear();
 218   1                    DelayMS(5);
 219   1                    lcd_write_string(0, 0, "ALARM turned off");
 220   1                    DelayMS(100);
 221   1                  }
 222   1                }
 223   1              }
 224   1              if(TH<limit){
 225   1                flag = 1;
 226   1              }
 227   1          }
 228   1      }*/
 229   1      }
 230          //将IO口设定为普通模式
 231          void io_init(void) {
 232   1      
 233   1          P0M0 = 0X00;
 234   1          P0M1 = 0X00;
 235   1          P1M0 = 0X00;
 236   1          P1M1 = 0X00;
 237   1          P2M0 = 0X00;
 238   1          P2M1 = 0X00;
 239   1          //P3M0=0X00;
 240   1          //P3M1=0X00;
C51 COMPILER V9.54   MAIN                                                                  07/05/2021 17:47:42 PAGE 5   

 241   1          P4M0 = 0X00;
 242   1          P4M1 = 0X00;
 243   1          P5M0 = 0X00;
 244   1          P5M1 = 0X00;
 245   1          DelayMS(5);
 246   1      }
 247          
 248          
 249          void DHT11_start() {
 250   1          Data = 1;
 251   1          Delay2US(1);
 252   1          Data = 0;
 253   1          DelayMS(20);
 254   1          Data = 1;
 255   1          Delay2US(10);
 256   1      }
 257          
 258          unsigned char DHT11_rec_byte() {                   //DHT11获取数据
 259   1          unsigned char i, dat = 0;
 260   1          for (i = 0; i < 8; i ++) {
 261   2              dat <<= 1;
 262   2              while (Data == 0);
 263   2              Delay2US(20);
 264   2              if (Data == 1) {
 265   3                  dat += 1;
 266   3                  while (Data);
 267   3              }
 268   2          }
 269   1          return dat;
 270   1      }
 271          
 272          void DHT11_receive() {                             //获取DHT11上的湿度和温度
 273   1          DHT11_start();
 274   1      
 275   1          if (Data == 0) {
 276   2      
 277   2              while (Data == 0);
 278   2      
 279   2              while (Data == 1);
 280   2              RH = DHT11_rec_byte();
 281   2              RL = DHT11_rec_byte();
 282   2              TH = DHT11_rec_byte();
 283   2              TL = DHT11_rec_byte();
 284   2              revise = DHT11_rec_byte();
 285   2      
 286   2              Delay2US(12);
 287   2      
 288   2              if ((RH + RL + TH + TL) == revise) {
 289   3      
 290   3                  rec_dat[0] = '0' + (RH / 10);;
 291   3                  rec_dat[1] = '0' + (RH % 10);
 292   3                  rec_dat[2] =' ';
 293   3                  rec_dat[3] = 'R' ;
 294   3                  rec_dat[4] = 'H';
 295   3                  rec_dat[5]=' ';
 296   3                  rec_dat[6]=' ';
 297   3                  rec_dat[7]=' ';
 298   3                  rec_dat[8]='0' + (TH / 10);
 299   3                  rec_dat[9] = '0' + (TH % 10);
 300   3                  rec_dat[10] = '.';
 301   3                  rec_dat[11] ='0'+TL;
 302   3                  rec_dat[12] = 'C';
C51 COMPILER V9.54   MAIN                                                                  07/05/2021 17:47:42 PAGE 6   

 303   3                  //rec_dat[13] = ' ' ;
 304   3                  //rec_dat[14]=' ';
 305   3              }
 306   2          }
 307   1      }
 308          
 309          
 310          
 311          
 312          
 313          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1049    ----
   CONSTANT SIZE    =    293    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     23      24
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
