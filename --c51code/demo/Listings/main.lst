C51 COMPILER V9.54   MAIN                                                                  07/05/2021 22:09:20 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keil\MDK\C51\BIN\C51.EXE src\main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings
                    -\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /************************************************************************************
   2          
   3          程序名称：1602显示屏测试程序   （晶振频率12MHz） 
   4          功能说明: 通过1602显示屏显示字符            
   5          程序版本：1.0 （2015/06）
   6          
   7          ************************************************************************************/
   8          
   9          
  10          #include <stdio.h>
  11          #include "stc15f2k60s2.h"                 // 单片机STC15F2K60S2头文件,可以不再加入reg51.h
  12          #include <intrins.h>                      // 加入此头文件后,可使用_nop_库函数
  13          #include "delay.h"                        // 延时函数头文件
  14          #include "1602.h"                         // 1602显示屏驱动程序头文件
  15          #include "uart.h"
  16          
  17          sbit Data = P1 ^7;
  18          sbit key1 = P2 ^3;
  19          sbit key2 = P2 ^2;
  20          sbit key3 = P2 ^1;
  21          sbit key4 = P2 ^0;
  22          sbit d1 = P5 ^2;
  23          sbit d2 = P5 ^1;
  24          sbit d3 = P5 ^0;
  25          
  26          int limit = 35;                                   //温度上限
  27          unsigned char rec_dat[13] = "   RH       C";
  28          unsigned char RH, RL, TH, TL, revise;
  29          unsigned char warnFlag = 0;                       //是否报警
  30          unsigned char kickFlag = 0;                       //是否取消报警
  31          char i;
  32          
  33          void io_init(void);
  34          void UartInit(void);
  35          void DHT11_receive();
  36          
  37          void main(void) {
  38   1          //unsigned char i = 0;
  39   1          unsigned char flag = 1;
  40   1          char strTemp[20]; 
  41   1          io_init();
  42   1          d3 = 0;
  43   1          lcd_init();                                   //LCD初始化
  44   1          DelayMS(5);
  45   1          lcd_clear();                                  //清屏函数
  46   1          DelayMS(5);
  47   1          lcd_write_string(0, 0, "hello EIE 194");
  48   1          //DelayMS(1000);
  49   1          TMOD = 0x01;
  50   1          TH0 = 0xD8;
  51   1          TL0 = 0xf0;
  52   1          EA = 1;
  53   1          ET0 = 1;
  54   1          TR0 = 1;
C51 COMPILER V9.54   MAIN                                                                  07/05/2021 22:09:20 PAGE 2   

  55   1          i = 0;
  56   1          while (1) {
  57   2              if(i = 100){
*** WARNING C276 IN LINE 57 OF src\main.c: constant in condition expression
  58   3                i = 0;
  59   3                DHT11_receive();  
  60   3              }
  61   2              if (key1 == 0) {                          //进入模式1
  62   3                  DelayMS(30);
  63   3                  if (key1 == 0) {
  64   4                      d1 = 0;
  65   4                      d2 = 1;
  66   4                      d3 = 1;
  67   4                      lcd_clear();
  68   4                      DelayMS(5);
  69   4                      lcd_write_string(0, 0, "MOD1         ");
  70   4                      lcd_write_string(0, 1, "The default mode");
  71   4                      while (key1 == 0);
  72   4                      DelayMS(200);
  73   4                      kickFlag = 0;
  74   4                      warnFlag = 0;
  75   4                  }
  76   3              }
  77   2              if (key2 == 0) {                          //进入模式2
  78   3                  DelayMS(30);
  79   3                  if (key2 == 0) {
  80   4                      d1 = 1;
  81   4                      d2 = 0;
  82   4                      d3 = 1;
  83   4                      lcd_clear();
  84   4                      DelayMS(5);
  85   4                      lcd_write_string(0, 0, "MOD2         ");
  86   4                      while (key2 == 0);
  87   4                      DelayMS(200);
  88   4                      DHT11_receive();
  89   4                      lcd_clear();
  90   4                      DelayMS(5);
  91   4                      lcd_write_string(0, 0, "COMMAND Mod");
  92   4                      lcd_write_string(0, 1, "Use K4 To UPDATE");
  93   4                      kickFlag = 0;
  94   4                      warnFlag = 0;
  95   4                  }
  96   3              }
  97   2              if (key3 == 0 && warnFlag == 0) {         //进入模式3――设定温度上限1
  98   3                  DelayMS(30);
  99   3                  if (key3 == 0) {
 100   4                      d1 = 1;
 101   4                      d2 = 1;
 102   4                      d3 = 0;
 103   4                      lcd_clear();
 104   4                      DelayMS(5);
 105   4                      lcd_write_string(0, 0, "MOD3         ");
 106   4                      while (key3 == 0);
 107   4                      DelayMS(200);
 108   4                      d3 = 1;
 109   4                      lcd_clear();
 110   4                      DelayMS(5);
 111   4                      lcd_write_string(0, 0, "SET upper limit");
 112   4                      lcd_write_string(0, 1, "USE K4 to SET");
 113   4                  }
 114   3              }
 115   2              if (d1 == 0) {                            //当蓝灯亮时，显示温度和湿度，并发送给上位机
C51 COMPILER V9.54   MAIN                                                                  07/05/2021 22:09:20 PAGE 3   

 116   3                  //DHT11_receive();  
 117   3                  lcd_clear();
 118   3                  DelayMS(5);
 119   3                  lcd_write_string(0, 0, "Auto detecting");
 120   3                  lcd_write_string(0, 1, rec_dat);
 121   3                  UartInit();
 122   3                  SendString(rec_dat);
 123   3                  DelayMS(1000);
 124   3              }
 125   2              if (d2 == 0) {                            //当绿灯亮时，按下k4可显示温度和湿度，并发送给上位机
 126   3                //DHT11_receive();
 127   3                lcd_clear();
 128   3                DelayMS(5);
 129   3                lcd_write_string(0, 0, "COMMAND Mod");
 130   3                lcd_write_string(0, 1, rec_dat);
 131   3                if (key4 == 0) {
 132   4                      DelayMS(30);
 133   4                      if (key4 == 0) {          
 134   5                          lcd_clear();
 135   5                          DelayMS(5);
 136   5                          lcd_write_string(0, 0, "Has been sent");
 137   5                          lcd_write_string(0, 1, rec_dat);
 138   5                          UartInit();
 139   5                          SendString(rec_dat);
 140   5                          DelayMS(1000);
 141   5                          while (key4 == 0);
 142   5                          DelayMS(100);
 143   5                      }
 144   4                  }/*else{
 145   3                      DHT11_receive();
 146   3                      lcd_clear();
 147   3                      DelayMS(5);
 148   3                      lcd_write_string(0, 0, "COMMAND Mod");
 149   3                      lcd_write_string(0, 1, "Use K4 To UPDATE");
 150   3                  }*/
 151   3                    
 152   3                  DelayMS(200);
 153   3              }
 154   2              if (d1 == 1 && d2 == 1 && d3 == 1 && warnFlag == 0) {      //设定温度上限2
 155   3                  if (key4 == 0) {
 156   4                      DelayMS(30);
 157   4                      if (key4 == 0) {
 158   5                          while (key4 == 0); 
 159   5                          DelayMS(100);
 160   5                          lcd_clear();
 161   5                      }
 162   4                      while (key4 != 0) {
 163   5                          //DHT11_receive();
 164   5                          DelayMS(5);
 165   5                          lcd_write_string(0, 0, "k1=up k2=down");
 166   5                          sprintf(strTemp, "%d", limit); 
 167   5                          lcd_write_string(0, 1, "    K4 to exit");
 168   5                          lcd_write_string(0, 1, strTemp);
 169   5                          if (key1 == 0) {
 170   6                              DelayMS(30);
 171   6                              if (key1 == 0) {
 172   7                                  limit ++;
 173   7                                  while (key1 == 0);
 174   7                              }
 175   6                          }
 176   5                          if (key2 == 0) {
 177   6                              DelayMS(30);
C51 COMPILER V9.54   MAIN                                                                  07/05/2021 22:09:20 PAGE 4   

 178   6                              if (key2 == 0) {
 179   7                                  limit --;
 180   7                                  while (key2 == 0);
 181   7                              }
 182   6                          }
 183   5                      }
 184   4                      d3=0;
 185   4                      DHT11_receive();
 186   4                      lcd_clear();
 187   4                      DelayMS(5);
 188   4                      lcd_write_string(0, 0, "SET Finish");
 189   4                      lcd_write_string(0, 1, "USE K1/K2 to Exit");
 190   4                      kickFlag = 0;
 191   4                      warnFlag = 0;
 192   4                  }
 193   3              }
 194   2              while(TH >= limit && kickFlag == 0){
 195   3                d1 = 1;
 196   3                d2 = 1;
 197   3                d3 = ~d3;
 198   3                warnFlag = 1;
 199   3                //DHT11_receive();
 200   3                lcd_clear();
 201   3                DelayMS(5);
 202   3                lcd_write_string(0, 0, "TEMP OVERRUN!"); 
 203   3                lcd_write_string(0, 1, "KICK K4 TO CLOSE");
 204   3                DelayMS(200);
 205   3                if(key4 == 0){
 206   4                  DelayMS(30);
 207   4                  if(key4==0){
 208   5                    d3 = 1;
 209   5                    kickFlag = 1;
 210   5                    warnFlag = 0;
 211   5                    //DHT11_receive();
 212   5                    lcd_clear();
 213   5                    DelayMS(5);
 214   5                    lcd_write_string(0, 0, "ALARM turned off");
 215   5                    DelayMS(1500);
 216   5                    lcd_write_string(0, 0, "hello EIE 194   ");
 217   5                  }
 218   4                }
 219   3              } 
 220   2           }
 221   1      /*        if(TH >= limit && flag == 1){
 222   1                if (key4 != 0) {
 223   1                  DelayMS(30);
 224   1                  if (key4 != 0) {
 225   1                    warning();
 226   1                    DelayMS(200);
 227   1                  }
 228   1                }
 229   1                if (key4 == 0) {  
 230   1                  DelayMS(30);
 231   1                  if (key4 == 0) {
 232   1                    flag=0;
 233   1                    d3 = 1;
 234   1                    DHT11_receive();
 235   1                    lcd_clear();
 236   1                    DelayMS(5);
 237   1                    lcd_write_string(0, 0, "ALARM turned off");
 238   1                    DelayMS(100);
 239   1                  }
C51 COMPILER V9.54   MAIN                                                                  07/05/2021 22:09:20 PAGE 5   

 240   1                }
 241   1              }
 242   1              if(TH<limit){
 243   1                flag = 1;
 244   1              }
 245   1          }
 246   1      }*/
 247   1      }
 248          
 249          void time0_int(void) interrupt 1{
 250   1        TH0 = 0xD8;
 251   1        TL0 = 0xf0;
 252   1        i++;
 253   1      }
 254          
 255          
 256          //将IO口设定为普通模式
 257          void io_init(void) {
 258   1      
 259   1          P0M0 = 0X00;
 260   1          P0M1 = 0X00;
 261   1          P1M0 = 0X00;
 262   1          P1M1 = 0X00;
 263   1          P2M0 = 0X00;
 264   1          P2M1 = 0X00;
 265   1          //P3M0=0X00;
 266   1          //P3M1=0X00;
 267   1          P4M0 = 0X00;
 268   1          P4M1 = 0X00;
 269   1          P5M0 = 0X00;
 270   1          P5M1 = 0X00;
 271   1          DelayMS(5);
 272   1      }
 273          
 274          
 275          void DHT11_start() {
 276   1          Data = 1;
 277   1          Delay2US(1);
 278   1          Data = 0;
 279   1          DelayMS(20);
 280   1          Data = 1;
 281   1          Delay2US(10);
 282   1      }
 283          
 284          unsigned char DHT11_rec_byte() {                   //DHT11获取数据
 285   1          unsigned char i, dat = 0;
 286   1          for (i = 0; i < 8; i ++) {
 287   2              dat <<= 1;
 288   2              while (Data == 0);
 289   2              Delay2US(20);
 290   2              if (Data == 1) {
 291   3                  dat += 1;
 292   3                  while (Data);
 293   3              }
 294   2          }
 295   1          return dat;
 296   1      }
 297          
 298          void DHT11_receive() {                             //获取DHT11上的湿度和温度
 299   1          DHT11_start();
 300   1      
 301   1          if (Data == 0) {
C51 COMPILER V9.54   MAIN                                                                  07/05/2021 22:09:20 PAGE 6   

 302   2      
 303   2              while (Data == 0);
 304   2      
 305   2              while (Data == 1);
 306   2              RH = DHT11_rec_byte();
 307   2              RL = DHT11_rec_byte();
 308   2              TH = DHT11_rec_byte();
 309   2              TL = DHT11_rec_byte();
 310   2              revise = DHT11_rec_byte();
 311   2      
 312   2              Delay2US(12);
 313   2      
 314   2              if ((RH + RL + TH + TL) == revise) {
 315   3      
 316   3                  rec_dat[0] = '0' + (RH / 10);;
 317   3                  rec_dat[1] = '0' + (RH % 10);
 318   3                  rec_dat[2] =' ';
 319   3                  rec_dat[3] = 'R' ;
 320   3                  rec_dat[4] = 'H';
 321   3                  rec_dat[5]=' ';
 322   3                  rec_dat[6]=' ';
 323   3                  rec_dat[7]=' ';
 324   3                  rec_dat[8]='0' + (TH / 10);
 325   3                  rec_dat[9] = '0' + (TH % 10);
 326   3                  rec_dat[10] = '.';
 327   3                  rec_dat[11] ='0'+TL;
 328   3                  rec_dat[12] = 'C';
 329   3                  rec_dat[13] = ' ' ;
 330   3                  rec_dat[14]=' ';
 331   3              }
 332   2          }
 333   1      }
 334          
 335          
 336          
 337          
 338          
 339          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1125    ----
   CONSTANT SIZE    =    287    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     23      23
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
